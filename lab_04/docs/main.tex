\input{style.tex}

\title{Lab 02 report}
\author{Kirill}

\date{\today}

\begin{document}
\thispagestyle{empty}

\noindent \begin{minipage}{0.15\textwidth}
	\includegraphics[width=\linewidth]{b_logo}
\end{minipage}
\noindent\begin{minipage}{0.85\textwidth}\centering
	\textbf{Министерство науки и высшего образования Российской Федерации}\\
	\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
	\textbf{«Московский государственный технический университет имени Н.Э.~Баумана}\\
	\textbf{(национальный исследовательский университет)»}\\
	\textbf{(МГТУ им. Н.Э.~Баумана)}
\end{minipage}

\noindent\rule{16cm}{3pt}
\newline\newline
\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»}}$ \newline\newline
\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»}}$\newline


\begin{center}
	\noindent\begin{minipage}{1.3\textwidth}\centering
	\Large\textbf{   ~~~ Лабораторная работа №4}\newline
	\textbf{по дисциплине "Анализ Алгоритмов"}\newline\newline\newline
	\end{minipage}
\end{center}

\noindent\textbf{Тема} $\underline{\text{Параллельное программирование}}$\newline\newline
\noindent\textbf{Студент} $\underline{\text{Рядинский К. В.}}$\newline\newline
\noindent\textbf{Группа} $\underline{\text{ИУ7-53Б}}$\newline\newline
\noindent\textbf{Преподаватель} $\underline{\text{Волкова Л. Л.}}$\newline

\begin{center}
	\mbox{}
	\vfill
	Москва
\end{center}

\begin{center}
	\the\year ~г.
\end{center}
\clearpage

\renewcommand\contentsname{\hfill{\normalfont{СОДЕРЖАНИЕ}}\hfill}  %Оглавление
\tableofcontents
\newpage

\anonsection{Введение}

Параллельные вычисления часто используются для увеличения скорости выполнения
программ. Однако приемы, применяемые для однопоточных машин, для
параллельных могут не подходить.

В данной лабораторной работе будет рассмотрено и реализованно параллельное
программирование на примере задачи вычисления среднего арифметического строки матрицы.

Целью данной работы является изучения параллельных вычислений на материале
задачи вычисления среднего арифметического строки матрицы.

В рамках выполнения работы необходимо решить следующие задачи:

\begin{enumerate}
	\item Изучения основ параллельных вычислений.
	\item Выбор и обоснование языка программирования, для решения данной задачи.
	\item Применение изученных основ для реализации многопоточности на материале задачи вычисления среднего арифметического строки матрицы.
	\item Получения практических навыков.
	\item Сравнительный анализ параллельной и однопоточной реализации алгоритма вычисления среднего арифметического строки матрицы.
	\item Экспериментальное подтверждение различий во временной эффективности реализации однопоточной и многопоточной версии вычисления среднего арифметического строки матрицы.
	\item Описание и обоснование полученных результатов.
\end{enumerate}


\section{Аналитическая часть}

В данном разделе будут рассмотрены алгоритм вычисления среднего арифметического строки матрицы и его параллельная реализиация.

\subsection{Алгоритм вычисления среднего арифметического строки матрицы}

Данный алгоритм создал для вычисления среднего арифметичского строки матрицы следующим образом: для каждой вычисляется ее сумма и делится на длину \footnote{Длиной строки мы будем называть количество элементов принадлежащей этой строке} этой строки.

\begin{equation}
    \bar{A_i} = \frac{\displaystyle\sum_{j = 1}^{n} A_{i, j}}{n}, i = \overline{1, m}
\end{equation}

\subsection{Параллельная реализация вычисления среднего арифметического строки матрицы}

Посколько в рассмотренном выше алгоритме каждая строка обрабатывается независимо, появляется возможность распределить обработку строк среди потоков.

\subsection{Вывод}

В данном разделе были рассмотрены алгоритм вычисления среднего арифметического строки матрицы и его параллельная реализиация.

В качестве входных данных в программу будут подаваться, размер матрицы, вещественная матрица (количество строк и столбцов). На выходе будет выдаваться массив, состоящий из средних арифметических строк матрицы. Ограничением для работы программного продукта будет являться то, что размеры матриц должны быть целыми положительными числами, а сами матрицы состоять только из вещественных значений. 

Реализуемое программное обеспечение будет работать в пользовательском и экспериментальном режимах. В пользовательском режиме можно будет ввести матрицу и программа выведет среднее арифметическое строк данной матрицы, в экспериментальном режиме будет проводиться сравнение временных характеристик последовательного и параллельного алгоритма нахождения среднего арифметического строк матрицы при разном количестве потоков.

Критерием, по которому данная реализиация будет сравниваться с другими реализациями, является время выполнения реализации алгоритма.


\section{Конструкторская часть}

В данном разделе будут представлены схемы алгоритмов (\ref{img:iter}-\ref{img:parallel}) и схемы вспомогательных функций (\ref{img:worker}-\ref{img:row_mean})). Описаны используемые типы данных, структура программного обеспечения (далее ПО) и классы эквивалентности.

\subsection{Схемы алгоритмов}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{iter.png}
    \caption{Схема последовательного алгоритма}
    \label{img:iter}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{parallel.png}
    \caption{Схема параллельного алгоритма}
    \label{img:parallel}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{worker.png}
    \caption{Схема вспомогательной функции worker}
    \label{img:worker}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{row_mean.png}
    \caption{Схема вспомогательной функции вычисления среднего арифметического строки}
    \label{img:row_mean}
\end{figure}


\subsection{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие структуры данных:

\begin{enumerate}
	\item Матрица --- одномерный массив типа float.
	\item Количество строк матрицы --- целое число типа long long.
	\item Количество столбцов матрицы --- целое число типа long long.
	\item Результирующий вектор --- одномерный массив типа float.
	\item Массив потоков --- одномерный массив типа std::thread.
\end{enumerate}

\subsection{Структура ПО}

ПО будет состоять из следующих модулей:

\begin{enumerate}
	\item main.cpp --- модуль, содержащий точку входа программы.
	\item matrix.cpp --- модуль, содержащий код алгоритмов нахождения среднего арифметического матрицы.
\end{enumerate}

\subsection{Способы тестирования и классы эквивалентности}

При тестировании алгоритмов была выбрана методика тестирования черным ящиком. Были выделены следующие классы эквивалентности:

\begin{enumerate}
	\item Матрица, заполненная случайными положительными числами.
	\item Матрица, заполненная построчно равными элементами.
	\item Матрица, содержащая один элемент.
	\item Пустая матрица.
\end{enumerate}

\subsection{Вывод}

В данном разделе были рассмотрены схемы алгоритмов (\ref{img:iter}-\ref{img:parallel}) и схемы вспомогательных функций (\ref{img:worker}-\ref{img:row_mean})). Описаны используемые типы данных, структура ПО, способы тестирования и классы эквивалентности.

\section{Технологическая часть}

В данном разделе приведены средства реализации и листинги кода.

\subsection{Средства реализации}

К языку программирования выдвигаются следующие требования:

\begin{enumerate}
	\item Возможность порождать системные потоки.
	\item Возможность производить замер времени выполнения части программы.
	\item Существуют среды разработки для этого языка.
\end{enumerate}

По этим требованиям был выбран язык программирования C++.

\subsection{Листинги кода}

\begin{lstlisting}[caption={Последовательный алгоритм}, label=list:iter, language={}]
real row_mean(const Matrix &m, size_t r) {
	real acc = 0;

	for (size_t c = 0; c < m.getcols(); c++) {
		acc += m(r, c);
	}

	return acc / m.getcols();
}

std::vector<real> Matrix::rows_mean() {
	std::vector<real> res(rows);


	for (size_t i = 0; i < rows; i++) {
		res[i] = row_mean(*this, i);
	}

	return res;
}
\end{lstlisting}

\begin{lstlisting}[caption=Параллельный алгоритм, label=list:iter, language={}]
static real row_mean(const real *ptr, size_t l) {
    real acc = 0;

    for (size_t i = 0; i < l; i++) {
        acc += ptr[i];
    }

    return acc / l;
}

static void rows_worker(const Matrix &m, size_t rl, size_t rr, std::vector<real> &res) {
    for (size_t r = rl; r < rr; r++) {
        res[r] = row_mean(m.getdata().data() + (r * m.getcols()), m.getcols());
    }
}

std::vector<real> Matrix::rows_mean_parallel(size_t t_num) {
    std::vector<std::thread> threads(t_num);
    std::vector<real> res(rows);

    size_t rpw       = rows / t_num; // rows per thread
    size_t remainder = rows % t_num;

    size_t t = 0;
    size_t r = 0;

    while (t < t_num && r < rows) {
        size_t right = r + rpw;

        if (remainder > 0) {
            right++;
            remainder--;
        }

        threads[t] = std::thread(rows_worker, std::cref(*this), r, right, std::ref(res));
        
        r = right;
        t++;
    }

    for (auto && i : threads) {
        i.join();
    }

    return res;
}
\end{lstlisting}

\subsection{Тестирование}

Тестирование проводилось методом черный ящик. \\

\begin{table}[ht]
	\caption{\centering Тестирование функций нахождения среднего арифметического строк матрицы}
	\centering
	\begin{tabular}{|c|c|c|}
	\hline
	Ввод                                                          & Фактический результат & Ожидаемый результат \\ \hline
	1 2 3                                                         & 2                     & 2                   \\ \hline
	()                                                            & ()                    & ()                  \\ \hline
	0                                                             & 0                     & 0                   \\ \hline
	\begin{tabular}[c]{@{}c@{}}1 1 1\\ 2 2 2\\ 1 2 1\end{tabular} & 1, 2, 1.333333        & 1, 2, 1.333333      \\ \hline
	\end{tabular}
	\label{tab:tests}
	\end{table}

\subsection{Вывод}

В данном разделе были представлены средства реализации, листинги кода и проведено тестирование кода.

\section{Экспериментальная часть}

В данном разделе будет произведено сравнение временных характеристик вышеизложенных алгоритмов.

\subsection{Пример работы программы}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{example.png}
    \caption{Пример работы программы}
    \label{img:example}
\end{figure}

\subsection{Технические характеристики}

Технические характеристики электронно-вычислительнй машины, на которой выполнялось тестирование:

\begin{itemize}
    \item операционная система: macOS BigSur версия 11.4;
    \item оперативная память: 8 гигабайт LPDDR4;
    \item процессор: Apple M1.
\end{itemize}


Тестирование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения рабочего стола, окружением рабочего стола, а также непосредственно системой тестирования.

\subsection{Временные характеристики}

Замер времени выполнения функций был произведен с помощью библиотеки Google Benchmark. Эта библиотека замеряет процессорное или реальное время (по выбору пользователя) выполнения функций, усредняет это значение и выдает результат в желаемом формате (csv, json, вывод в терминал).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{plot.png}
    \caption{Зависимость времени выполнения алгоритма от размера квадратной матрицы}
    \label{img:benchmark}
\end{figure}

Как видно из графика \ref{img:benchmark}, параллельная реализация алгоритма быстрее последовательного как минимум в 2.5 раза для двух потоков. Также из графика видно, что для машины, на которой производилось тестирование, не имеет смысла порождать более 8 потоков, так как производительность почти не растет, но на создание потоков уходят ресурсы (память).

\subsection{Вывод}

В данном разделе было произведено сравнение реализаций алгоритмов и зависимость времени работы от количества потоков и сделаны соответствующие заключения.

\anonsection{Заключение}

В данной лабораторной работе были рассмотрены основополагающие материалы, которые в дальнейшем потребовались для параллельной и последовательной реализаций алгоритма вычисления среднего арифметического строки матрицы. 

В рамках данной лабораторной работы была достигнута цель и выполнены следующие задачи:

\begin{enumerate}
	\item Изучены основы параллельных вычислений.
	\item Выбран и обоснован язык программирования, для решения данной задачи.
	\item Примененены изученные основы для реализации многопоточности на материале задачи вычисления среднего арифметического строки матрицы.
	\item Получены практические навыки.
	\item Был проведен сравнительный анализ параллельной и однопоточной реализации алгоритма вычисления среднего арифметического строки матрицы.
	\item Было экспериментально подтверждено различия во временной эффективности реализации однопоточной и многопоточной версии вычисления среднего арифметического строки матрицы.
	\item Были описаны и обоснованы полученные результаты.
\end{enumerate}

\anonsection{Список литературы}

\begin{enumerate}
	\item Visual Studio Code [Электронный ресурс], режим доступа: https://code.visualstudio.com/ (дата обращения: \today)
	\item LPDDR4 [Электронный ресурс] \url{https://ru.wikipedia.org/wiki/LPDDR#LPDDR4} (дата обращения: \today)
	\item Ульянов М. В. Ресурсно-эффективные компьютерные алгоритмы. Разработка и Анализ. - Наука Физматлит, 2007. - 376.
	\item Библиотека Chrono [Электронный ресурс] Режим доступа: https://en. cppreference.com/w/cpp/chrono (дата обращения: \today).
	\item Библиотека для работы с потоками thread [Электронный ресурс] Режим доступа: https://en.cppreference.com/w/cpp/thread (дата обращения: \today).
\end{enumerate}

\end{document}
