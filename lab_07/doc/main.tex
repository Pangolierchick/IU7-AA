\input{style.tex}

\title{Lab 02 report}
\author{Kirill}

\date{\today}

\begin{document}
\thispagestyle{empty}

\noindent \begin{minipage}{0.15\textwidth}
    \includegraphics[width=\linewidth]{b_logo}
\end{minipage}
\noindent\begin{minipage}{0.85\textwidth}\centering
    \textbf{Министерство науки и высшего образования Российской Федерации}\\
    \textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
    \textbf{«Московский государственный технический университет имени Н.Э.~Баумана}\\
    \textbf{(национальный исследовательский университет)»}\\
    \textbf{(МГТУ им. Н.Э.~Баумана)}
\end{minipage}

\noindent\rule{16cm}{3pt}
\newline\newline
\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»}}$ \newline\newline
\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»}}$\newline


\begin{center}
    \noindent\begin{minipage}{1.3\textwidth}\centering
    \Large\textbf{   ~~~ Лабораторная работа №7}\newline
    \textbf{по дисциплине "Анализ Алгоритмов"}\newline\newline\newline
    \end{minipage}
\end{center}

\noindent\textbf{Тема} $\underline{\text{Поиск в словаре}}$\newline\newline
\noindent\textbf{Студент} $\underline{\text{Рядинский К. В.}}$\newline\newline
\noindent\textbf{Группа} $\underline{\text{ИУ7-53Б}}$\newline\newline
\noindent\textbf{Преподаватель} $\underline{\text{Волкова Л. Л.}}$\newline

\begin{center}
    \mbox{}
    \vfill
    Москва
\end{center}

\begin{center}
    \the\year ~г.
\end{center}
\clearpage

\renewcommand\contentsname{\hfill{\normalfont{СОДЕРЖАНИЕ}}\hfill}  %Оглавление
\tableofcontents
\newpage

\anonsection{Введение}

Словарь или ассоциативный массив -- абстрактный тип данных (интерфейс к хранилищу данных, позволяющий хранить пары вида (ключ; значение) и поддерживающий операции добавления пары, а также поиска и удаления пары по ключу.

В паре $(k,v)$ значение $v$ называется значением ассоциированным с ключом $k$. Семантика и названия вышеупомянутых операций в разных реализациях ассоциативного массива могут отличаться.

Ассоциативный массив с точки зрения интерфейса удобно рассматривать как обычный массив: в котором в качестве индексов можно использовать не только целые числа, но и значения других типов -- например, строк.

Поддержка ассоциативных массивов есть во многих языках программирования высокого уровня, таких, как \texttt{Perl}, \texttt{PHP}, \texttt{Python}, \texttt{JavaScript} и других. Для языков, не имеющих встроенных средств для работы с ассоциативными массивами, существует множество реализаций в виде библиотек.

Целью данной лабораторной работы является изучение способа эффективного оиска по словарю. Для достижения данной цели необходимо решить следующие задачи:

\begin{enumerate}
    \item Изучить алгоритмы поиска по словарю.
    \item Протестировать алгоритмы поиска по словарю.
    \item Замерить и сравнить количество сравнений алгоритмов.
    \item Сделать вывод на основе проделанной работы.
\end{enumerate}

\section{Аналитическая часть}

В данном разделе представлены теоретические сведения о рассматриваемых алгоритмах.

\subsection{Алгоритм полного перебора}

Алгоритмом полного перебора называют метод решения задачи, при котором по очереди рассматриваются все возможные варианты исходного набора данных. В случае словарей будет произведен последовательный перебор элементов словаря до тех пор, пока не будет найден необходимый. сложность такого алгоритма зависит от количества всех возможных решений, а время работы может стремиться к экспоненциальному.

Пусть алгоритм нашел элемент на первом сравнении. Тогда, в лучшем случае, будет затрачено $k_0 + k_1$ операций, на втором -- $k_0 + 2k_1$, на $N$ -- $k_0 + Nk_1$. тогда, средняя трудоемкость может быть рассчитано по формуле \eqref{eq:brute}, где $\Omega$ - множество всех возможных случаев.

\begin{equation}
   \label{eq:brute}
   \sum_{i \in \Omega} p_i t_i = (k_0 + k_1) \frac{1}{N + 1} + (k_0 + 2k_1) * \frac{1}{N + 1} + \dots + (k_0 + Nk_1) * \frac{1}{N + 1} 
\end{equation}

Из формулы \eqref{eq:brute}, сгруппировав слагаемые, получим итоговую формулу для расчета средней трудоемкости работы алгоритма:

\begin{equation}
   k_0 + k1(\frac{N}{N + 1} + \frac{N}{2}) = k_0 + k1(1 + \frac{N}{2} - \frac{1}{N + 1}) 
\end{equation}

\subsection{Алгоритм двоичного поиска}

Данный алгоритм применяется к заранее упорядоченным словарям. Процесс двоичного поиска можно описать при помощи шагов:
\begin{itemize}
    \item сравнить значение ключа, находящегося в середине рассматриваемого интервала (изначально -- весь словарь), с данным;
    \item в случае, если значение меньше (в контексте типа данных) данного, продолжить поиск в левой части интервала, в обратном - в правой;
    \item продолжать до тех пор, пока найденное значение не будет равно данному или длина интервала не станет равной нулю (означает отсутствие искомого ключа в словаре).
\end{itemize}

Использование данного алгоритма для поиска в словаре в любом из случаев будет иметь трудоемкость равную $O(log_2(N))$ . Несмотря на то, что в среднем и худшем случаях данный алгоритм работает быстрее алгоритма полного перебора, стоит отметить, что предварительная сортировка больших данных требует дополнительных затрат по времени и может оказать серьезное действие на время работы алгоритма. Тем не менее, при многократном поиске по одному и тому же словарю, применение алгоритм сортировки понадобится всего один раз.

\subsection{Алгоритм частотного анализа}

Алгоритм частотного анализа строит частотный анализ полученного словаря. Чтобы провести частотный анализ, нужно взять первый элемент каждого значения в словаре по ключу и подсчитать частотную характеристику, т.е. сколько раз этот элемент встречался в качестве первого. По полученным данным словарь разбивается на сегменты так, что все записи с одинаковым первым элементом оказываются в одном сегменте.

Сегменты упорядочиваются по значению частотной характеристики таким образом, чтобы к элементу с наибольшим значением характеристики был предоставлен самый быстрый доступ.

Затем каждый из сегментов упорядочивается по значению. Это необходимо для реализации бинарного поиска, который обеспечит эффективный поиск в сегмента при сложности $O(nlog(n))$

таким образом, сначала выбирается нужный сегмент, а затем в нем проводится бинарный поиск  нужного элемента. Средняя трудоемкость при длине алфавита $M$ может быть рассчитана по формуле \eqref{eq:freq}.

\begin{equation}
   \sum_{i \in [1, M]} (f_{select_i} + f_{search_i})
   \label{eq:freq}
\end{equation}

\subsection{Описание словаря}

В данной работе словарь будет иметь следующий вид: \textit{название игры : разработчик}. Поиск будет произведен по ключу \textit{название игры}.

\subsection{Вывод}

В данном разделе были рассмотрены основополагающие материалы, которые в дальнейшем потребуются при реалиации алгоритмов поиска по словаю.

В качестве входных данных программе будут подаваться: файл, содержащий исходный словарь; ключ, по которому будет производиться поиск. Ограничением для работы программного продукта будут являться, что файл должен существовать и содержать корректные данные. Ключ должен являться корректной строкой (иметь длину более 1 символа).

Реализуемое программное обеспечение будет работать в двух режимах: экспериментальном и пользовательском. В пользовательском режиме может будет ввести ключ, по которому будет произведен поиск по словарю. В экспериментальном режиме будет возможность сравнить реализованные алгоритмы по временным характеристикам.

Критериеми, по которому данная реализация будет сравниваться с другими реализациями, будут являться: время работы алгоритма и количество сравнений, произведенных по ходу работы алгоритма.

\section{Конструкторская часть}

В данном разделе будут рассмотрены схемы работы алгоритмов, используемые типы данных и структура программного обеспечения (далее ПО).

\subsection{Схемы алгоритмов}

На схемах \ref{img:default}-\ref{img:seg} представлены реализации алгоритмов поиска по словарю.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{default.png}
    \caption{Алгоритм поиска методом полного перебора}
    \label{img:default}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{bin_1.png}
    \label{img:bin_1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{bin_2.png}
    \caption{Алгоритм поиска методом дихотомии}
    \label{img:bin_1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{seg.png}
    \caption{Алгоритм поиска методом частотного анализа}
    \label{img:seg}
\end{figure}

\subsection{Описание структуры программного обеспечения}

На рисунке \ref{img:uml} представлена \textit{uml} диаграмма разрабатываемого программного обеспечения.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{uml.png}
    \caption{Структура программного обеспечения}
    \label{img:uml}
\end{figure}

\subsection{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие структуры данных:

\begin{itemize}
    \item ключ --- строка;
    \item словарь --- двумерный массив строк.
\end{itemize}

\subsection{Структура программного обеспечения}

Программное обеспечение состоит из следующих модулей:

\begin{itemize}
    \item main.lua --- модуль, содержащий код точки входа;
    \item search.lua --- модуль, содержащий код функций поиска;
    \item type.lua --- модуль, содержащий объявление словаря;
    \item benchmark.lua --- модуль, содержащий функции замера временных характеристик.
\end{itemize}

\subsection{Тестирование}

Тестирование будет проводиться методом черный ящик. В таблице \ref{tab:tests} представлены тесты. \\

\begin{table}[H]
    \caption{Тестирование представленных реализаций алгоритмом поиска по словарю}
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    Ввод              & Ожидаемый результат                & Фактический результат              \\ \hline
    qop               & qop Quiet River                    & qop Quiet River                    \\ \hline
    theHunter Classic & theHunter Classic Expansive Worlds & theHunter Classic Expansive Worlds \\ \hline
    Dota 3            & Не найдено                         & Не найдено                         \\ \hline
    \end{tabular}
    \label{tab:tests}
\end{table}

\subsection{Вывод}

В данном разделе были представлены схемы алгоритмов, структура по, типы данных, тесты.

\section{Технологическая часть}

В данном разделе приведены средства реализации и листинги кода.

\subsection{Средства реализации}

К языку программирования выдвигаются следующие требования:

\begin{enumerate}
    \item Возможность производить замер времени выполнения части программы.
    \item Существуют среды разработки для этого языка.
    \item Возможность чтение из файла, запись в файл, создание массивов.
\end{enumerate}

По этим требованиям был выбран язык Lua.

\subsection{Листинги кода}


\begin{lstlisting}[caption=Словарь, label=list:matrix, language={}]
Game = {}

Game.__index = Game

function Game:New(n, c)
    assert(n ~= nil and c ~= nil, 'name and company must be provided')
    
    local self = setmetatable({}, Game)
    
    self.game = n
    self.company = c

    return self
end

function Game:__tostring()
    return self.game .. " : " .. self.company 
end
    
return Game
\end{lstlisting}

\begin{lstlisting}[caption=Точка входа, label=list:matrix, language={}]
local s = require 'split'
local csv = require 'csv'
local game = require 'type'
local search = require 'search'
local bench = require 'benchmark'
local cmp = require 'cmp_count'

function main()
    data, err = csv.read('../data/data1.csv', ';')

    local dict = {}

    for i, v in ipairs(data) do
        local g = Game:New(v[1], v[2])

        table.insert(dict, g)
    end

    io.write("Ipnut game name: ")
    local g_name = io.stdin:read('l')

    io.write('Benchmark? (y/n): ')

    local y_n_debug = io.stdin:read('l')
    local finder = search:New(dict)

    if y_n_debug == 'y' then
        local res = total_cmp(dict)

        dump_cmps(res, '../data/cmps.csv')

        print(string.format("Default: %f", bench.cpu_run(function ()
            finder:default(g_name)
        end, 1000, 'ns')))
        print(string.format("Binary:  %f", bench.cpu_run(function ()
            finder:binary(g_name)
        end, 1000, 'ns')))
        print(string.format("Segment: %f", bench.cpu_run(function ()
            finder:segment(g_name)
        end, 1000, 'ns')))
    else
        local sd = finder:default(g_name) or 'not found'
        local sb = finder:binary(g_name)  or 'not found'
        local ss = finder:segment(g_name) or 'not found'

        print('Default:', sd[1], sd[2])
        print('Binary: ', sb[1], sb[2])
        print('Segment:', ss[1], ss[2])
    end
end

main()
\end{lstlisting}

\begin{lstlisting}[caption=Реализация алгоритмов поиска, label=list:matrix, language={}]
local search = {}
search.__index = search

function search:New(h)
    local self = setmetatable({}, search)

    self.haystack = h
    self.segments = nil

    return self
end

function search:default(needle)
    local haystack = self.haystack

    local comp = 0

    for i, v in ipairs(haystack) do
        comp = comp + 1
        if v.game == needle then
            return {v, comp}
        end
    end

    return {nil, comp}
end

function search:binary(needle)
    local haystack = self.haystack
    local left = 1
    local right = #haystack

    local comp = 0

    while left <= right do
        local middle = math.floor((left + right) / 2)

        if (haystack[middle].game == needle) then
            comp = comp + 1
            return {haystack[middle], comp}
        elseif haystack[middle].game < needle then
            comp = comp + 2
            left = middle + 1
        else
            comp = comp + 2
            right = middle - 1
        end
    end

    return {nil, comp}
end

local function letter_freq(haystack)
    local res = {}

    for i, v in ipairs(haystack) do
        if res[v.game:sub(1, 1)] == nil then
            res[v.game:sub(1, 1)] = { v }
        else
            table.insert(res[v.game:sub(1, 1)], v)
        end
    end

    return res
end

function search:segment(needle)
    local haystack = self.haystack

    if self.segments == nil then
        self.segments = letter_freq(haystack)
    end

    local letter = needle:sub(1, 1)
    local cmp = 0
    for k, v in pairs(self.segments) do
        cmp = cmp + 1
        if k == letter then
            local value = search:New(v)
            local res = value:binary(needle)
            
            res[2] = res[2] + cmp
            return res
        end
    end

    return nil
end

return search
\end{lstlisting}

\subsection{Вывод}

В данном разделе были разработаны алгоритмы поиска.

\section{Исследовательский раздел}

В данном разделе будет проведен замер временных характеристик выполнения алгоритмов и пример работы программы.

\subsection{Пример работы программы}

На рисунке \ref{img:ex} представлен пример запуска программы. \\

\begin{figure}[H]
    \centering
    \includegraphics[scale=1.2]{ex.png}
    \caption{Пример работы программы}
    \label{img:ex}
\end{figure}

\subsection{Технические характеристики}

Технические характеристики электронно-вычислительной машины, на которой выполнялось тестирование:

\begin{itemize}
    \item операционная система: macOS BigSur версия 11.4;
    \item оперативная память: 8 гигабайт LPDDR4;
    \item процессор: Apple M1.
\end{itemize}

\subsection{Временные характеристики}

В данном работе более интересующей нас характеристикой будет являться количество сравнений, необходимое для нахождения ключа, так как от количества сравнений прямо пропорционально зависит время работы алгоритма. Количество элементов в словаре примерно 2500.

Поиск будет проводиться с помощью каждого реализованного алгоритма, после чего будут представлены соответствующие графики. В каждом построенном графике данные будут отсортированы по возрастанию, так как количество сравнений для алгоритмов, не использующих полный перебор, количество сравнений будет являться "случайной" величиной.

\subsubsection{Алгоритм полного перебора}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.55]{plot_def.png}
    \caption{График количества сравнений для алгоритма поиска полным перебором}
    \label{img:plot_def}
\end{figure}

Как видно из графика \ref{img:plot_def} количество сравнений линейно зависит количества элементов в словаре. Лучшим случаем для алгоритма полного перебора будет являться нахождение искомого элемента в самом начале словаря, тогда как худшим будет являться элемент, находящийся в самом конце словаря.

\subsubsection{Алгоритм бинарного поиска}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.55]{plot_bin.png}
    \caption{График количества сравнений для алгоритма поиска методом дихотомии (данные в графике отсортированы по возрастанию)}
    \label{img:plot_bin}
\end{figure}

Как видно из графика \ref{img:plot_bin} минимальное количество сравнений равно 1 (элемент находится ровно по середине), а максимальное равно 23. По сравнению с последовательным алгоритмом среднее количество сравнений отличается примерно в 61 раз.

\subsubsection{Алгоритм частотного анализа}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.55]{plot_seg.png}
    \caption{График количества сравнений для алгоритма частотного анализа (данные в графике отсортированы по возрастанию)}
    \label{img:plot_seg}
\end{figure}

Так как словарь содержит не только буквы латинского словаря, то в худшем случае потребуется пройти по всему списку алфавита начальных букв словаря, что может потребовать значительное количество сравнений.

На рисунке \ref{img:plot_seg} видно, что в лучшем случае потребуется 2 сравнения (элемент находится по середине первого сегмента). В худшем же 52 сравнения. В среднем количество сравнений в алгоритме полного перебора и алгоритме частотного анализа отличаются в 46 раз. Но по сравнению с алгоритмом бинарного поиска в 1.36 сравнений больше.

\subsection{Вывод}

Исходя из вышеперечисленных данных, можно сделать вывод, что наиболее эффективным алгоритмом поиска является бинарный алгоритм. Алгоритм частотного анализа же лишь в особых случаях будет быстрее бинарного поиска (если алфавит будет сильно ограничен и размер словаря будет очень большим), так как требуется произвести сегментацию словаря, что требует значительное количество времени.

Отдельно стоит отметить, что бинарному поиску требуется подавать на вход отсортированный словарь, на что может потребоваться значительное количество времени и в единичных случаях поиска последовательный алгоритм может быть эффективнее. Но если требуется произвести серию поисков, то время, затраченное на сортировку словаря, окупится сниженным временем поиска.

\anonsection{Заключение}

В данном лабораторной работе были изучены алгоритмы поиска по словарю.

Среди рассмотренных алгоритмов наиболее эффективным оказался алгоритм бинарного поиска.

В рамках данной работы была выполнена цель и решены следующие задачи:

\begin{enumerate}
    \item Изучены алгоритмы поиска по словарю.
    \item Протестированы алгоритмы поиска по словарю.
    \item Замерено и сравнено количество сравнений алгоритмов.
    \item Сделаны выводы на основе проделанной работы.
\end{enumerate}

\anonsection{Список литературы}

\begin{enumerate}
    \item Visual Studio Code [Электронный ресурс], режим доступа: https://code.visualstudio.com/ (дата обращения: \today)
	\item LPDDR4 [Электронный ресурс] \url{https://ru.wikipedia.org/wiki/LPDDR#LPDDR4} (дата обращения: \today)
	\item Ульянов М. В. Ресурсно-эффективные компьютерные алгоритмы. Разработка и Анализ. - Наука Физматлит, 2007. - 376.
	\item Язык Lua. [Электронный ресурс] Режим доступа: https://www.lua.org (дата обращения: \today)
	\item Вирт Н. Алгоритмы + структуры данных = программы. — М.: «Мир», 1985. — С. 28.
\end{enumerate}

\end{document}
